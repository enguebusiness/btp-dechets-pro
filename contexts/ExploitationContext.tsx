'use client'

import { createContext, useContext, useEffect, useState, useCallback, ReactNode } from 'react'
import { createClient } from '@/lib/supabase'
import type { Exploitation, AlerteCertificat } from '@/types/database'
import type { User, AuthChangeEvent } from '@supabase/supabase-js'

const STORAGE_KEY = 'bio-audit-active-exploitation'

interface ExploitationContextType {
  exploitations: Exploitation[]
  activeExploitation: Exploitation | null
  setActiveExploitation: (exploitation: Exploitation | null) => void
  loading: boolean
  error: string | null
  refreshExploitations: () => Promise<void>
  createExploitation: (data: Partial<Exploitation>) => Promise<Exploitation | null>
  updateExploitation: (id: string, data: Partial<Exploitation>) => Promise<boolean>
  user: User | null
  alertesCertificats: AlerteCertificat[]
  refreshAlertes: () => Promise<void>
}

const ExploitationContext = createContext<ExploitationContextType | undefined>(undefined)

export function ExploitationProvider({ children }: { children: ReactNode }) {
  const [exploitations, setExploitations] = useState<Exploitation[]>([])
  const [activeExploitation, setActiveExploitationState] = useState<Exploitation | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [user, setUser] = useState<User | null>(null)
  const [alertesCertificats, setAlertesCertificats] = useState<AlerteCertificat[]>([])
  const [initialized, setInitialized] = useState(false)
  const supabase = createClient()

  // Charger l'exploitation active depuis le localStorage
  const loadStoredExploitation = useCallback((exploitationsList: Exploitation[]) => {
    if (typeof window === 'undefined' || exploitationsList.length === 0) {
      return exploitationsList.length > 0 ? exploitationsList[0] : null
    }

    const storedId = localStorage.getItem(STORAGE_KEY)
    if (storedId) {
      const found = exploitationsList.find(e => e.id === storedId)
      if (found) return found
    }

    // Si aucune exploitation stockée ou non trouvée, prendre la première
    return exploitationsList[0]
  }, [])

  // Sauvegarder l'exploitation active dans le localStorage
  const setActiveExploitation = useCallback((exploitation: Exploitation | null) => {
    setActiveExploitationState(exploitation)
    if (typeof window !== 'undefined') {
      if (exploitation) {
        localStorage.setItem(STORAGE_KEY, exploitation.id)
      } else {
        localStorage.removeItem(STORAGE_KEY)
      }
    }
  }, [])

  // Charger les alertes certificats fournisseurs
  const refreshAlertes = useCallback(async () => {
    if (!activeExploitation) {
      setAlertesCertificats([])
      return
    }

    try {
      const { data: certificats } = await supabase
        .from('certificats_fournisseurs')
        .select('*')
        .eq('exploitation_id', activeExploitation.id)

      if (!certificats) {
        setAlertesCertificats([])
        return
      }

      const alertes: AlerteCertificat[] = []
      const today = new Date()

      certificats.forEach((cert: { id: string; fournisseur_nom: string; date_expiration: string }) => {
        const expiration = new Date(cert.date_expiration)
        const daysUntilExpiration = Math.ceil((expiration.getTime() - today.getTime()) / (1000 * 60 * 60 * 24))

        if (daysUntilExpiration < 0) {
          alertes.push({
            id: cert.id,
            fournisseur: cert.fournisseur_nom,
            type: 'expire',
            message: `Certificat expire depuis ${Math.abs(daysUntilExpiration)} jours`,
            date_expiration: cert.date_expiration,
            severity: 'critical',
          })
        } else if (daysUntilExpiration <= 30) {
          alertes.push({
            id: cert.id,
            fournisseur: cert.fournisseur_nom,
            type: 'expiration_proche',
            message: `Certificat expire dans ${daysUntilExpiration} jours`,
            date_expiration: cert.date_expiration,
            severity: 'warning',
          })
        }
      })

      setAlertesCertificats(alertes)
    } catch (err) {
      console.error('Erreur chargement alertes:', err)
    }
  }, [activeExploitation, supabase])

  // Charger les exploitations depuis Supabase
  const refreshExploitations = useCallback(async () => {
    try {
      setLoading(true)
      setError(null)

      const { data: userData } = await supabase.auth.getUser()
      if (!userData.user) {
        setExploitations([])
        setActiveExploitationState(null)
        setUser(null)
        setLoading(false)
        return
      }

      setUser(userData.user)

      // Essayer avec owner_id d'abord (nouvelle structure)
      let { data, error: fetchError } = await supabase
        .from('exploitations')
        .select('*')
        .eq('owner_id', userData.user.id)
        .order('created_at', { ascending: false })

      // Si erreur, essayer avec user_id (ancienne structure)
      if (fetchError && fetchError.code !== '42P01') {
        const result = await supabase
          .from('exploitations')
          .select('*')
          .eq('user_id', userData.user.id)
          .order('created_at', { ascending: false })
        data = result.data
        fetchError = result.error
      }

      if (fetchError) {
        if (fetchError.code === '42P01') {
          console.log('Table exploitations non trouvée')
          setExploitations([])
          setLoading(false)
          return
        }
        throw fetchError
      }

      const exploitationsList = (data as Exploitation[]) || []
      setExploitations(exploitationsList)

      // TOUJOURS sélectionner une exploitation par défaut si disponible
      if (exploitationsList.length > 0) {
        const active = loadStoredExploitation(exploitationsList)
        if (active) {
          setActiveExploitationState(active)
          if (typeof window !== 'undefined') {
            localStorage.setItem(STORAGE_KEY, active.id)
          }
        }
      } else if (userData.user.user_metadata?.company_name) {
        // Créer une exploitation par défaut depuis les métadonnées
        const newExploitation = await createExploitationFromMetadata(userData.user)
        if (newExploitation) {
          setExploitations([newExploitation])
          setActiveExploitation(newExploitation)
        }
      }

      setInitialized(true)
    } catch (err) {
      console.error('Erreur chargement exploitations:', err)
      setError(err instanceof Error ? err.message : 'Erreur inconnue')
    } finally {
      setLoading(false)
    }
  }, [supabase, loadStoredExploitation, setActiveExploitation])

  // Créer une exploitation depuis les métadonnées utilisateur
  const createExploitationFromMetadata = async (userData: User): Promise<Exploitation | null> => {
    try {
      const exploitationData = {
        owner_id: userData.id,
        name: userData.user_metadata?.company_name || 'Mon exploitation',
        siret: userData.user_metadata?.siret || null,
        email: userData.email,
      }

      const { data, error: insertError } = await supabase
        .from('exploitations')
        .insert(exploitationData)
        .select()
        .single()

      if (insertError) {
        console.error('Erreur création exploitation:', insertError)
        return null
      }

      return data as Exploitation
    } catch (err) {
      console.error('Erreur création exploitation:', err)
      return null
    }
  }

  // Créer une nouvelle exploitation
  const createExploitation = async (exploitationData: Partial<Exploitation>): Promise<Exploitation | null> => {
    try {
      const { data: userData } = await supabase.auth.getUser()
      if (!userData.user) throw new Error('Non authentifié')

      const { data, error: insertError } = await supabase
        .from('exploitations')
        .insert({
          ...exploitationData,
          owner_id: userData.user.id,
        })
        .select()
        .single()

      if (insertError) throw insertError

      const newExploitation = data as Exploitation
      setExploitations(prev => [newExploitation, ...prev])
      setActiveExploitation(newExploitation)

      return newExploitation
    } catch (err) {
      console.error('Erreur création exploitation:', err)
      setError(err instanceof Error ? err.message : 'Erreur création')
      return null
    }
  }

  // Mettre à jour une exploitation
  const updateExploitation = async (id: string, exploitationData: Partial<Exploitation>): Promise<boolean> => {
    try {
      const { error: updateError } = await supabase
        .from('exploitations')
        .update({
          ...exploitationData,
          updated_at: new Date().toISOString(),
        })
        .eq('id', id)

      if (updateError) throw updateError

      // Mettre à jour l'état local
      setExploitations(prev =>
        prev.map(e => (e.id === id ? { ...e, ...exploitationData } : e))
      )

      // Mettre à jour l'exploitation active si c'est celle-ci
      if (activeExploitation?.id === id) {
        setActiveExploitationState(prev => prev ? { ...prev, ...exploitationData } : null)
      }

      return true
    } catch (err) {
      console.error('Erreur mise à jour exploitation:', err)
      setError(err instanceof Error ? err.message : 'Erreur mise à jour')
      return false
    }
  }

  // Écouter les changements d'authentification
  useEffect(() => {
    refreshExploitations()

    const { data: { subscription } } = supabase.auth.onAuthStateChange((event: AuthChangeEvent) => {
      if (event === 'SIGNED_IN' || event === 'TOKEN_REFRESHED') {
        refreshExploitations()
      } else if (event === 'SIGNED_OUT') {
        setExploitations([])
        setActiveExploitationState(null)
        setUser(null)
        setAlertesCertificats([])
        if (typeof window !== 'undefined') {
          localStorage.removeItem(STORAGE_KEY)
        }
      }
    })

    return () => {
      subscription.unsubscribe()
    }
  }, [refreshExploitations, supabase.auth])

  // Charger les alertes quand l'exploitation active change
  useEffect(() => {
    if (initialized && activeExploitation) {
      refreshAlertes()
    }
  }, [activeExploitation, initialized, refreshAlertes])

  return (
    <ExploitationContext.Provider
      value={{
        exploitations,
        activeExploitation,
        setActiveExploitation,
        loading,
        error,
        refreshExploitations,
        createExploitation,
        updateExploitation,
        user,
        alertesCertificats,
        refreshAlertes,
      }}
    >
      {children}
    </ExploitationContext.Provider>
  )
}

export function useExploitation() {
  const context = useContext(ExploitationContext)
  if (context === undefined) {
    throw new Error('useExploitation doit être utilisé dans un ExploitationProvider')
  }
  return context
}
